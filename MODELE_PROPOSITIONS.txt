================================================================================
PROPOSITIONS DE MODÈLES - FORMAT BRUT POUR CONCEPTION RAPIDE
================================================================================

================================================================================
1. USER
================================================================================
id (UUID, PK)
role_id (UUID, FK -> roles.id)
email (String, unique, not null)
password_hash (String, nullable)
auth_provider (String, nullable) - 'google', 'github', 'email', etc.
email_verified (Boolean, default=false)
email_verified_at (DateTime, nullable)
password_reset_token (String, nullable)
password_reset_expires_at (DateTime, nullable)
avatar_url (String, nullable)
is_active (Boolean, default=true)
last_login_at (DateTime, nullable)
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: email, role_id, is_active, created_at

================================================================================
2. PROFILE
================================================================================
id (UUID, PK)
user_id (UUID, FK -> user.id, unique, not null)
name (String, nullable)
firstname (String, nullable)
city (String, nullable)
country (String, nullable)
phone (String, nullable)
email (String, nullable)
website (String, nullable)
company_id (UUID, nullable) - renommé depuis idCompany
avatar_url (String, nullable)
bio (Text, nullable)
timezone (String, nullable)
language (String, default='fr')
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: user_id, email, city, company_id

================================================================================
3. ROLES
================================================================================
id (UUID, PK)
name (String, unique, not null) - 'admin', 'user', 'premium', etc.
description (String, nullable)
permissions (JSONB, nullable) - permissions en JSON
is_active (Boolean, default=true)
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: name, is_active

================================================================================
4. PRICING_PLANS (renommé depuis princing_plans)
================================================================================
id (UUID, PK)
name (String, not null)
description (Text, nullable)
price (Decimal, not null)
currency (String, default='EUR')
price_promo (Decimal, nullable)
price_promo_start_date (DateTime, nullable)
price_promo_end_date (DateTime, nullable)
billing_period (String, not null) - 'monthly', 'yearly', 'lifetime'
max_prospects (Integer, nullable) - null = illimité
max_prospects_per_hour (Integer, nullable)
max_prospects_per_day (Integer, nullable)
count_limit (Integer, nullable)
geoloc_limit (Integer, nullable)
features (JSONB, nullable) - liste des features en JSON
sort_order (Integer, default=0) - pour l'affichage
is_active (Boolean, default=true)
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: is_active, sort_order, billing_period
CHECK: price >= 0
CHECK: price_promo_end_date > price_promo_start_date (si les deux présents)

================================================================================
5. ABONNEMENT
================================================================================
id (UUID, PK)
user_id (UUID, FK -> user.id, not null)
pricing_plan_id (UUID, FK -> pricing_plans.id, not null)
start_date (DateTime, not null)
end_date (DateTime, not null)
auto_renew (Boolean, default=true)
cancelled_at (DateTime, nullable)
cancellation_reason (String, nullable)
payment_status (String, default='pending') - 'pending', 'paid', 'failed', 'refunded'
stripe_subscription_id (String, nullable) - si paiement Stripe
stripe_customer_id (String, nullable)
is_active (Boolean, default=true)
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: user_id, pricing_plan_id, is_active, end_date
INDEX COMPOSITE: (user_id, is_active) - pour requêtes fréquentes
CHECK: end_date > start_date

================================================================================
6. SEARCH_HISTORY
================================================================================
id (UUID, PK)
user_id (UUID, FK -> user.id, not null)
search_type_id (UUID, FK -> search_types.id, nullable) - ou String si enum
search_query (String, not null)
results_count (Integer, default=0)
execution_time_ms (Integer, nullable)
filters_applied (JSONB, nullable) - filtres utilisés en JSON
location (JSONB, nullable) - {lat, lon, radius} si recherche géolocalisée
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: user_id, created_at, search_type_id
INDEX COMPOSITE: (user_id, created_at DESC) - pour historique utilisateur

================================================================================
7. SEARCH_RESULTS
================================================================================
id (UUID, PK)
search_history_id (UUID, FK -> search_history.id, not null)
result_type (String, nullable) - 'prospect', 'company', etc.
result_data (JSONB, not null) - données complètes du résultat
score (Float, nullable) - score de pertinence
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: search_history_id, created_at, result_type

================================================================================
8. BLACK_LIST
================================================================================
id (UUID, PK) - MANQUANT ACTUELLEMENT
email (String, unique, not null)
user_id (UUID, FK -> user.id, nullable) - si liste noire par utilisateur, sinon null = globale
reason (String, nullable) - raison du blocage
date_end (DateTime, nullable) - null = permanent
is_active (Boolean, default=true)
created_at (DateTime, not null)
updated_at (DateTime, not null) - MANQUANT ACTUELLEMENT

INDEX: email, user_id, is_active, date_end

================================================================================
9. COMPANY (nouvelle table si company_id référencé)
================================================================================
id (UUID, PK)
name (String, not null)
siret (String, nullable, unique)
address (String, nullable)
city (String, nullable)
country (String, nullable)
website (String, nullable)
phone (String, nullable)
email (String, nullable)
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: name, siret, city

================================================================================
10. SEARCH_TYPES (nouvelle table si search_type_id référencé)
================================================================================
id (UUID, PK)
name (String, unique, not null) - 'osm', 'linkedin', 'facebook', etc.
description (String, nullable)
is_active (Boolean, default=true)
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: name, is_active

================================================================================
11. USER_SESSIONS (nouvelle table optionnelle)
================================================================================
id (UUID, PK)
user_id (UUID, FK -> user.id, not null)
token_hash (String, not null, unique)
ip_address (String, nullable)
user_agent (String, nullable)
expires_at (DateTime, not null)
created_at (DateTime, not null)

INDEX: user_id, token_hash, expires_at

================================================================================
12. API_KEYS (nouvelle table optionnelle si API prévue)
================================================================================
id (UUID, PK)
user_id (UUID, FK -> user.id, not null)
key_hash (String, not null, unique)
name (String, not null) - nom donné par l'utilisateur
last_used_at (DateTime, nullable)
expires_at (DateTime, nullable) - null = jamais
is_active (Boolean, default=true)
created_at (DateTime, not null)
updated_at (DateTime, not null)

INDEX: user_id, key_hash, is_active

================================================================================
RELATIONS PRINCIPALES
================================================================================

user (1) ──→ (1) profile
user (N) ──→ (1) roles
user (N) ──→ (1) abonnement ──→ (1) pricing_plans
user (N) ──→ (N) search_history ──→ (N) search_results
user (N) ──→ (N) black_list (optionnel : peut être globale sans user_id)
profile (N) ──→ (1) company (si table company existe)

================================================================================
NOTES IMPORTANTES
================================================================================

1. Tous les IDs sont UUID (comme dans vos modèles existants)
2. Tous les timestamps sont DateTime avec timezone
3. Les champs nullable sont marqués explicitement
4. Les Foreign Keys doivent être définies avec ondelete='CASCADE' ou 'SET NULL' selon besoin
5. Soft delete : considérer ajouter deleted_at sur user, profile, pricing_plans, abonnement
6. Black list : décider si globale (user_id nullable) ou par utilisateur (user_id not null)

================================================================================
PRIORITÉS D'IMPLÉMENTATION
================================================================================

URGENT:
- Corriger princing_plans → pricing_plans
- Ajouter id à black_list
- Ajouter updated_at à black_list
- Ajouter toutes les Foreign Keys

IMPORTANT:
- Ajouter champs manquants (email_verified, auto_renew, etc.)
- Créer table company si nécessaire
- Créer table search_types si nécessaire

OPTIONNEL:
- Tables user_sessions et api_keys si besoin
- Soft delete (deleted_at)
- Audit trail (created_by, updated_by)

================================================================================
